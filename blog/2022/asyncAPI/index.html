<!DOCTYPE html> <html lang="en"> <head> <meta name="google-site-verification" content=""/> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>How to develop an Asynchronous REST API with Python, Flask, Gunicorn and Celery | Viet-Phi Huynh</title> <meta name="author" content="Viet-Phi Huynh"/> <meta name="description" content="Viet-Phi Huynh personal webpage. "/> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://huynhvp.github.io/blog/2022/asyncAPI/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Viet-Phi </span>Huynh</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">How to develop an Asynchronous REST API with Python, Flask, Gunicorn and Celery</h1> <p class="post-meta">November 1, 2022</p> <p class="post-tags"> <a href="/blog/2022"> <i class="fas fa-calendar fa-sm"></i> 2022 </a>   ·   <a href="/blog/tag/dev"> <i class="fas fa-hashtag fa-sm"></i> dev</a>     ·   <a href="/blog/category/api"> <i class="fas fa-tag fa-sm"></i> API,</a>   <a href="/blog/category/python"> <i class="fas fa-tag fa-sm"></i> python,</a>   <a href="/blog/category/flask"> <i class="fas fa-tag fa-sm"></i> flask,</a>   <a href="/blog/category/gunicorn"> <i class="fas fa-tag fa-sm"></i> gunicorn,</a>   <a href="/blog/category/celery"> <i class="fas fa-tag fa-sm"></i> celery</a>   </p> </header> <article class="post-content"> <p><b>Table of Contents</b></p> <ul id="markdown-toc"> <li><a href="#what-is-rest-api-" id="markdown-toc-what-is-rest-api-"><b>What is REST API ?</b></a></li> <li><a href="#problems-of-synchronous-api" id="markdown-toc-problems-of-synchronous-api"><b>Problems of Synchronous API</b></a></li> <li><a href="#asynchronous-api" id="markdown-toc-asynchronous-api"><b>Asynchronous API</b></a></li> </ul> <h2 id="what-is-rest-api-"><b>What is REST API ?</b></h2> <p><b>API</b> (Application Programming Interface) is a software interface that allows one application to communicate with another application. <strong>REST API</strong> (Representational State Transfer) can be understood as a web service API where two applications talk to each other over a network (e.g. internet). Imagine that you are developing and deploying a system with a lot of interesting functionalities, you want to share it with your clients so that they can integrate your tools into their application workflow. To some extent, the client would appreciate a friendly and easy access to your application server. Instead of reading every line of your code to see what is going on inside algorithms, they prefer an abstract understanding of the behavior of the application like: what does this application do, what are the required formats/types of input/output. To this end, <strong>REST API</strong> delivers a set of friendly functions like <strong>POST, GET, DELETE</strong> to your application server in order for clients to easily communicate.</p> <p><b>Example</b>: Wikipedia provides a REST API for retrieving the information of a Wikipedia entity. For instance, to get a description of France country:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">curl -X GET https://en.wikipedia.org/api/rest_v1/page/summary/France | jq  '.extract'

Output:

</span><span class="gp">"France, officially the French Republic, is a transcontinental country predominantly located in Western Europe and spanning overseas regions and territories in the Americas and the Atlantic, Pacific and Indian Oceans. Its metropolitan area extends from the Rhine to the Atlantic Ocean and from the Mediterranean Sea to the English Channel and the North Sea;</span><span class="w"> </span>overseas territories include French Guiana <span class="k">in </span>South America, Saint Pierre and Miquelon <span class="k">in </span>the North Atlantic, the French West Indies, and many islands <span class="k">in </span>Oceania and 
<span class="go">the Indian Ocean. Due to its several coastal territories, France has the largest exclusive economic zone in the world. France borders Belgium, Luxembourg, Germany, Switzerland, Monaco, Italy, Andorra, and Spain in continental Europe, as well as the Netherlands, 
Suriname, and Brazil in the Americas via its overseas territories in French Guiana and Saint Martin. Its eighteen integral regions 
span a combined area of 643,801 km2 (248,573 sq mi) and close to 68 million people. France is a unitary semi-presidential republic 
</span><span class="gp">with its capital in Paris, the country's largest city and main cultural and commercial centre;</span><span class="w"> </span>other major urban areas include Marseille, Lyon, Toulouse, Lille, Bordeaux, and Nice.<span class="s2">"
</span></code></pre></div></div> <p><b>Flask</b> is a lightweight Python web framework which allows to write web application in Python quickly and easily.</p> <p><b>Gunicorn</b> is a Python Web Server Gateway Interface (WSGI) server playing as an intermediate between the web application server and the client. It receives requests from client, forwards it to web application and sends back the result to client.</p> <blockquote> <p>Flask is shipped with some basic web server features, therefore, for development purpose, it is acceptable if Flask is used as WSGI server. However, in production, it is recommended using a real WSGI server, such as Gunicorn.</p> </blockquote> <h2 id="problems-of-synchronous-api"><b>Problems of Synchronous API</b></h2> <p>In synchronous API, a synchronous worker handles a single request at a time, the client and the server communicate uninterruptedly back and forth in the same time frame.</p> <p>Assuming you are building a web server which supports a <code class="language-plaintext highlighter-rouge">long-running task</code> using Flask and Gunicorn.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># server.py
</span><span class="kn">from</span> <span class="n">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">jsonify</span><span class="p">,</span> <span class="n">make_response</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">app</span> <span class="o">=</span> <span class="nc">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="nd">@app.route</span><span class="p">(</span><span class="sh">"</span><span class="s">/long_running_task</span><span class="sh">"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">POST</span><span class="sh">"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">long_running_task</span><span class="p">():</span>
    <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="c1">## represents long-running task
</span>    <span class="k">return</span>  <span class="nf">make_response</span><span class="p">(</span><span class="nf">jsonify</span><span class="p">({</span><span class="sh">'</span><span class="s">result</span><span class="sh">'</span><span class="p">:</span> <span class="sh">"</span><span class="s">done long-running task</span><span class="sh">"</span><span class="p">}),</span> <span class="mi">200</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="sh">'</span><span class="s">0.0.0.0</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># web server endpoint
# wsgi.py
</span><span class="kn">from</span> <span class="n">server</span> <span class="kn">import</span> <span class="n">app</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
</code></pre></div></div> <p>the server is listening at port 5000 and is configured one synchronous worker to handle requests sent from clients.</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">gunicorn --workers 1  --bind 0.0.0.0:5000 wsgi:app

[2022-10-30 21:06:01 +0100] [976] [INFO] Starting gunicorn 20.1.0
[2022-10-30 21:06:01 +0100] [976] [INFO] Listening at: http://0.0.0.0:5000 (976)
[2022-10-30 21:06:01 +0100] [976] [INFO] Using worker: sync
[2022-10-30 21:06:01 +0100] [978] [INFO] Booting worker with pid: 978
</span></code></pre></div></div> <p>If a client application sends a request to the server for executing the <code class="language-plaintext highlighter-rouge">long-running task</code>, its workflow will be blocked for ~30 (s) until it receives the respone from the server. In other words, the whole application is not able to handle others tasks during this time.</p> <blockquote> <p>One solution for this issue is to use async workers, such <a href="https://docs.gunicorn.org/en/stable/design.html" target="_blank" rel="noopener noreferrer">Greenlets, gthread</a> for the server side, or <a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener noreferrer">asyncio</a> for the client side. However, due to their thread-based nature, these kinds of async workers are only suitable for I/O-bound application.</p> </blockquote> <h2 id="asynchronous-api"><b>Asynchronous API</b></h2> <p>Asynchronous API comes up with the idea that in the web server, a heavy process should stay outside the main workflow of the server as well as outside the request/response cycle between client and server. Instead, it should be handled in background. By this way, when a client sends a request, the server can put the request into a task queue and let a task orchestrator (e.g. Celery) pick up a worker to deal with it, the client is immediately acknowledged with a <code class="language-plaintext highlighter-rouge">task_id</code>, the client can continue to do other things without waiting for the termination of the request, they can get back later to the server with the <code class="language-plaintext highlighter-rouge">task_id</code> when the result is ready. Also, the server is free to accept other requests from other users.</p> <p><b>Celery</b> is a distributed task queue that allows to schedule and process vast amount of tasks on different machines. It has 3 main components:</p> <ul> <li>A message broker (e.g. RabbitMQ, Redis) is a messaging bridge between the web server application (Flask) and (remote) workers. It manages the task queue by receiving task requests from the application, distributing tasks across different workers and delivering task’ s status back to client.</li> <li>A backend (e.g. Redis, MongoDB) stores the task’s results returned from workers.</li> <li>A pool of (distributed) workers in which each worker looks at the task queue and pick up a task to handle independently of other workers and outside the context of main system.</li> </ul> <p>The client request/server response cycle is illustrated in the figure below:</p> <p><img src="/assets/img/async_api/workflow.png" alt="" style="width: 100%; display:block; margin-left:auto; margin-right:auto"></p> <p>We choose Redis (in-memory key-value database) as Message Broker and Result Backend. More information about Celery’s Broker &amp; Backend can be found at <a href="https://docs.celeryq.dev/en/master/getting-started/backends-and-brokers/index.html" target="_blank" rel="noopener noreferrer">here</a>. Among possible backends, according to my experience, RPC:RabbitMQ should not be considered since it is <a href="https://patrick.cloke.us/posts/2019/10/04/celery-amqp-backends/" target="_blank" rel="noopener noreferrer">limited in functionality</a> and contains <a href="https://github.com/celery/celery/issues/4084" target="_blank" rel="noopener noreferrer">bugs</a>.</p> <p>Let’s go ahead and implement each stage in the workflow.</p> <p><b>(0)</b> As Celery task queue requires a redis broker and a redis backend. We first install redis via docker:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">docker run --name broker-backend -d redis -p 6379:6379
</span></code></pre></div></div> <p>The redis server is listening at port 6379. We next initialize the task queue:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># server.py
</span><span class="bp">...</span>
<span class="bp">...</span>

<span class="sh">"""</span><span class="s"> CELERY CONFIG </span><span class="sh">"""</span>
<span class="kn">from</span> <span class="n">celery</span> <span class="kn">import</span> <span class="n">Celery</span>
<span class="n">celery</span> <span class="o">=</span> <span class="nc">Celery</span><span class="p">(</span><span class="sh">"</span><span class="s">async_tasks</span><span class="sh">"</span><span class="p">,</span> <span class="n">broker</span><span class="o">=</span><span class="sh">'</span><span class="s">redis://localhost:6379/0</span><span class="sh">'</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="sh">'</span><span class="s">redis://localhost:6379/0</span><span class="sh">'</span><span class="p">,</span> 
		<span class="n">task_ignore_result</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">task_track_started</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">task_ignore_result</code> is set to False to enable storing task’s results to the backend. If the task is picked up by a worker and <code class="language-plaintext highlighter-rouge">task_track_started</code> is True, a status <code class="language-plaintext highlighter-rouge">STARTED</code> will be reported to the broker.</p> <p><b>(1) + (2)</b> Create a celery async task to handle <code class="language-plaintext highlighter-rouge">long_running_task</code>. It stays outside the main event loop and is executed by a separate worker.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># server.py
</span><span class="bp">...</span>
<span class="bp">...</span>
<span class="c1"># create a celery async task that handles `long_running_task` 
# by wrapping the function with @celery.task decorator.
</span><span class="nd">@celery.task</span><span class="p">(</span><span class="n">bind</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">async_tasks.long_running_task</span><span class="sh">'</span><span class="p">,</span> <span class="n">task_acks_late</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">async_long_running_task</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span> <span class="c1">## represents long-running task	
</span>    <span class="k">return</span> <span class="sa">f</span><span class="sh">"</span><span class="s">done long-running task </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="sh">"</span>

</code></pre></div></div> <p>With <code class="language-plaintext highlighter-rouge">bind=True</code>, the task has access to the <a href="https://docs.celeryq.dev/en/latest/userguide/tasks.html#bound-tasks" target="_blank" rel="noopener noreferrer">attributes</a> of task instance, such as <code class="language-plaintext highlighter-rouge">task id</code>, <code class="language-plaintext highlighter-rouge">task states</code>. If <code class="language-plaintext highlighter-rouge">task_acks_late</code> is enabled, even when the task fails (e.g. killed due to OOM) or timeout, its status will be acknowledged.</p> <p>We then open a route from client to server for <code class="language-plaintext highlighter-rouge">POST /async_long_running_task</code> request. The Flask server accepts the request from client, does not actually execute the request (as in Synchronous API), but rather put it in the task queue using <code class="language-plaintext highlighter-rouge">delay</code> function. An <code class="language-plaintext highlighter-rouge">task_id</code> will be ACK immediately. The client can do other things, such as making a second request to the server without waiting for the first one to finish.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># server.py
</span><span class="bp">...</span>
<span class="bp">...</span>
<span class="c1"># create a route from client to server for POST /task request
</span><span class="nd">@app.route</span><span class="p">(</span><span class="sh">'</span><span class="s">/async_long_running_task</span><span class="sh">'</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">POST</span><span class="sh">"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">submit_task_to_taskQueue</span><span class="p">():</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">async_long_running_task</span><span class="p">.</span><span class="nf">delay</span><span class="p">()</span>
    <span class="k">return</span> <span class="nf">make_response</span><span class="p">(</span><span class="nf">jsonify</span><span class="p">({</span><span class="sh">'</span><span class="s">task_id</span><span class="sh">'</span><span class="p">:</span> <span class="n">task</span><span class="p">.</span><span class="nb">id</span><span class="p">}),</span> <span class="mi">202</span><span class="p">)</span>
    
</code></pre></div></div> <p>Now, let’s launch the Celery workers.</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">celery -A server.celery worker --concurrency=1 --loglevel=info

--- ***** -----
-- ******* ---- Linux-4.19.128-microsoft-standard-x86_64-with-glibc2.10 2022-11-01 11:55:08
- *** --- * ---
- ** ---------- [config]
</span><span class="gp">- ** ---------- .&gt;</span><span class="w"> </span>app:         async_tasks:0x7f48e2da5130
<span class="gp">- ** ---------- .&gt;</span><span class="w"> </span>transport:   redis://localhost:6379/0
<span class="gp">- ** ---------- .&gt;</span><span class="w"> </span>results:     redis://localhost:6379/0
<span class="gp">- *** --- * --- .&gt;</span><span class="w"> </span>concurrency: 1 <span class="o">(</span>prefork<span class="o">)</span>
<span class="gp">-- ******* ---- .&gt;</span><span class="w"> </span>task events: OFF <span class="o">(</span><span class="nb">enable</span> <span class="nt">-E</span> to monitor tasks <span class="k">in </span>this worker<span class="o">)</span>
<span class="go">--- ***** -----
 -------------- [queues]
</span><span class="gp">                .&gt;</span><span class="w"> </span>celery           <span class="nv">exchange</span><span class="o">=</span>celery<span class="o">(</span>direct<span class="o">)</span> <span class="nv">key</span><span class="o">=</span>celery
<span class="go">
[tasks]
  . async_tasks.long_running_task

[2022-11-01 11:55:08,104: INFO/MainProcess] Connected to redis://localhost:6379/0
[2022-11-01 11:55:08,109: INFO/MainProcess] mingle: searching for neighbors
[2022-11-01 11:55:09,119: INFO/MainProcess] mingle: all alone
[2022-11-01 11:55:09,130: INFO/MainProcess] celery@YD-H02M403 ready.
</span></code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">--concurrency=1</code> indicates the number of workers (1) which defaults to the number of available CPUs. We can also verify that celery workers are correctly connected to redis broker and backend. It currently supports 1 async task class: <code class="language-plaintext highlighter-rouge">async_tasks.long_running_task</code>.</p> <p>Sound good so far ! Let’s try to send a request to the API:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">curl -X POST  localhost:5000/async_long_running_task   

{"task_id":"923733ec-2285-4295-9613-558703248957"}
</span></code></pre></div></div> <p>We receive straight away an unique id <code class="language-plaintext highlighter-rouge">923733ec-2285-4295-9613-558703248957</code> for the request we’ve sent.</p> <p><b>(3)</b> With <code class="language-plaintext highlighter-rouge">task_id</code>, we can check the status of the request anytime. For this, we create a route from client to server for <code class="language-plaintext highlighter-rouge">GET status /&lt;task_id&gt;</code>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># server.py
</span><span class="bp">...</span>
<span class="bp">...</span>
<span class="c1"># create a route from client to server for GET /&lt;task_id&gt; status
</span><span class="nd">@app.route</span><span class="p">(</span><span class="sh">'</span><span class="s">/async_long_running_task/&lt;task_id&gt;</span><span class="sh">'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">check_task_status</span><span class="p">(</span><span class="n">task_id</span><span class="p">):</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">async_long_running_task</span><span class="p">.</span><span class="nc">AsyncResult</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">make_response</span><span class="p">(</span><span class="nf">jsonify</span><span class="p">({</span><span class="sh">'</span><span class="s">task_status</span><span class="sh">'</span><span class="p">:</span> <span class="n">task</span><span class="p">.</span><span class="n">status</span><span class="p">}),</span> <span class="mi">200</span><span class="p">)</span>
</code></pre></div></div> <p>Let’s check the status of request we’ve sent:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">curl localhost:5000/async_long_running_task/923733ec-2285-4295-9613-558703248957

{"task_status":"STARTED"}
</span></code></pre></div></div> <p>The task involved would require ~30 (s) to process. If we check its status less than 30 (s) since we launched it, we would get <code class="language-plaintext highlighter-rouge">STARTED</code> meaning that the task is started by the worker, but not finished yet. After 30 (s), we will have <code class="language-plaintext highlighter-rouge">SUCCESS</code> status:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">curl localhost:5000/async_long_running_task/923733ec-2285-4295-9613-558703248957

{"task_status":"SUCCESS"}
</span></code></pre></div></div> <p>For more information about possible built-in states in celery, have a look at <a href="https://docs.celeryq.dev/en/stable/reference/celery.states.html" target="_blank" rel="noopener noreferrer">here</a>.</p> <p>Two important remarks:</p> <ul> <li>State <code class="language-plaintext highlighter-rouge">PENDING</code> is vague. On the one hand, it means that the task is well positioned in the queue but is not picked up yet by the workers. But on the other hands, it also means the task does not exist because we provided a wrong <code class="language-plaintext highlighter-rouge">task_id</code>.</li> <li>Apart from built-in states, we can enrich the state set by adding <a href="https://www.distributedpython.com/2018/09/28/celery-task-states/" target="_blank" rel="noopener noreferrer">custom states</a>, for example, in order to ensure a smooth tracking of a heavy-duty task, we can detail the progress of the task by adding states such as <code class="language-plaintext highlighter-rouge">IN PROGRESS</code> or <code class="language-plaintext highlighter-rouge">STEP 1</code>, <code class="language-plaintext highlighter-rouge">STEP 2</code>.</li> </ul> <p><b>(4)</b> Once the task is successfully executed, its result is stored in the backend.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># server.py
</span><span class="bp">...</span>
<span class="bp">...</span>
<span class="c1"># create a route from client to server for GET result /&lt;task_id&gt; 
</span><span class="nd">@app.route</span><span class="p">(</span><span class="sh">'</span><span class="s">/async_long_running_task/&lt;task_id&gt;/result</span><span class="sh">'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_task_result</span><span class="p">(</span><span class="n">task_id</span><span class="p">):</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">async_long_running_task</span><span class="p">.</span><span class="nc">AsyncResult</span><span class="p">(</span><span class="n">task_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">task</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="sh">"</span><span class="s">SUCCESS</span><span class="sh">"</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">make_response</span><span class="p">(</span><span class="nf">jsonify</span><span class="p">({</span><span class="sh">'</span><span class="s">task_result</span><span class="sh">'</span><span class="p">:</span> <span class="n">task</span><span class="p">.</span><span class="n">result</span><span class="p">}),</span> <span class="mi">200</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">make_response</span><span class="p">(</span><span class="nf">jsonify</span><span class="p">({</span><span class="sh">'</span><span class="s">message</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">Task not finished yet !</span><span class="sh">'</span><span class="p">}),</span> <span class="mi">200</span><span class="p">)</span>
</code></pre></div></div> <p>We are now able to collect the task’s result by sending a <code class="language-plaintext highlighter-rouge">GET result /&lt;task_id&gt;</code> request:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">curl localhost:5000/async_long_running_task/923733ec-2285-4295-9613-558703248957/result

{"task_result":"done long-running task 923733ec-2285-4295-9613-558703248957"}
</span></code></pre></div></div> <p><b>Voilà</b>, in this blog post, we have gone through a step-by-step tutorial on building a simple python-based asynchronous REST API. Hope you enjoyed it <img class="emoji" title=":slightly_smiling_face:" alt=":slightly_smiling_face:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f642.png" height="20" width="20"></p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Viet-Phi Huynh. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="noopener noreferrer">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>